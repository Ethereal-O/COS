# Lab1-Reliable Data Transport Protocol

## 信息

学号：520021910550
姓名：杨景凯
邮件：sxqxyjk2020@sjtu.edu.cn

## 实现细节

### 包头设计

使用8字节包头，包含4字节的checksum，1字节的payload_size，1字节的index，1字节的sequence_number，1字节的acknowledgment_sequence_number。
- checksum：
  - 我使用了CRC去实现checksum。这是因为CRC具有更好的识别错误能力。而由于普通的checksum求和的期望与原值相等，故错误可能被更大概率遗漏。
  - 我使用32位checksum，经过测试，在1000次测试，每次模拟时间1000s，传输耗时0.1s，平均大小100bytes，乱序概率0.3，丢失概率0.3，错误概率0.3，最终错误次数为0次。
- payload_size：即存在的data大小。
- index：指在当前message中的位置。
- sequence_number：指传输序号。
  - 传输序号是一个小于10\*WINDOW_SIZE的数值，使得其可以在1个字节内不溢出。当序号增长到大于10\*WINDOW_SIZE时，即变为0。这样设计是为了receiver能够知道当前的序号，将过时的包进行丢弃，同时根据此值更新window。
- acknowledgment_sequence_number：确认号。简单地将传输序号复制到此位置，表示当前序号已经被receiver确认。

## 发送设计

- 维护一个链表，存储所有未发送的包，这样使得上层的消息不会被阻断。当消息到来时，将其转换为包，并加入链表的尾部。
- 当收到包时，更新window中当前位置包的接收状态，并检查是否能够更新整个window。
- 当当前window中所有包已经被确认收到，即更新window，将当前window中包delete（防止内存泄漏）,从链表中取出包，放入window。由于只有一个全局的timer，因此我们不能针对每个包设置timer，只能对整个窗口设置。
- 当超时时，检查window中未被确认收到的包，重新发送。

## 接收设计

- 当收到包时，根据包头中的sequence_number更新window。如果发送端已经是下一组window，则清理所有window中的包，按顺序发送消息。如果是当前组，则简单赋值。如果是过时组，则丢弃。
  - 正确性保证：当发送端更新时，接收端所有应该接收到的包已经被全部接收到，因此可以更新。
  - 适应性保证：接收端并不知道当前window总共需要发送多少个包，因此这样设计使得接收端不被阻塞。这样也保证了唯一性，重复发送的包只被向上层发送一次。
- 最终，将window中所有包发送到上层。

## 效率设计

- 使用Selective Repeat方式，因为这使得发送的包数量更少，时长更短。经过测试，在约发送1000000个bytes时，大约发送60000个包，时长4400s。
- 与参考值相比，几乎没有区别，时间上稍微有所区别（参考值4300s），这主要有两个原因：
  - 我只使用了一个全局的timer，这使得设计更方便，不需要不停的更新timer并且使用额外的数据结构来针对每个window中元素储存timer。
  - 包数据可能较小。因为我设置了更长的checksum。但是，如果只使用16位，那么经过测试，在1000次测试中大约有100次出错。这显然是不能容忍的。（使用32位1000次测试出错0次）（测试只需要将rdt_receiver.cc和rdt_sender.cc中header结构体中checksum更改类型即可，后续修改使用decltype和sizeof自动完成）

## 遇到的问题与解决

- 最大的问题即为过时的处理。我设置了最长过时周期。即当一个包如果延迟一整个循环再次出现时，就会认为其是新包。这个问题难以解决，只能尽可能避免，而在当前模拟的实现中是不可能出现的，最多只可能延迟两三个window周期。因此只需要设置最长过时周期即可解决。
- 空window问题。如果当前消息队列中没有任何包需要发送，但是之后会有（导致模拟未停止），进而使得窗口序列号空增长而不发送信息。这个问题与上述问题同时出现时，无论是从debug还是从修复后检查效果都是棘手的。我使用python分析输出，逐步找到了这个问题，解决了它。
- 另一个问题是，当前的模拟并不计算重复处理包造成的损失。但是当TIMEOUT调为0.3时，有些每个包会发送3次以上！当TIMEOUT调为0.2时，有些会发送10次以上！或许在实际中不是一个可行的方案？