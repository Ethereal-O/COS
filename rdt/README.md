# Lab1-Reliable Data Transport Protocol

## 信息

学号：520021910550
姓名：杨景凯
邮件：sxqxyjk2020@sjtu.edu.cn

## 实现细节

### 包头设计

1. 数据包
使用10字节包头，包含4字节的checksum，4字节的pkt_ID，1字节的has_more，1字节的payload_size。
- checksum：
  - 我使用了$\mathop{\Sigma}\limits_{i=0}\limits^{N}i \cdot data[i]$去实现checksum。这是因为这样使得checksum期望不是0，具有更好的识别错误能力。而由于普通的checksum求和的期望与原值相等，故错误可能被更大概率遗漏。
  - 我使用32位checksum，经过测试，在1000次测试，每次模拟时间1000s，传输耗时0.1s，平均大小100bytes，乱序概率0.3，丢失概率0.3，错误概率0.3，最终错误次数为0次。
- pkt_ID：指传输序号。
- has_more：当前message是否有更多包。
- payload_size：指包大小。

2. ack
使用8字节包头，包含4字节的checksum，4字节的pkt_ID。
- pkt_ID：表示被接收的最大连续pkt_ID。

## 发送设计

- 维护一个链表，存储所有未发送的包，这样使得上层的消息不会被阻断。当消息到来时，将其转换为包，并加入链表的尾部。
- 当收到包时，根据收到的pkt_ID判断接收端已经接收到的最大的连续的包，判断更新window的数目，从链表中取出包，放入window。
- 当超时时，从最低未被确认收到的包开始全部发送当前窗口中所有包。

## 接收设计

- 当收到包时，根据包头中的pkt_ID更新window。如果是当前组但是不是当前需要接收的最低ID，则简单赋值。如果是过时组，则丢弃。如果是最低ID，则更新window。如果当前window已经被赋值（发送两次），则顺序找到最大没有被赋值过的位置。返回已经接收到的最大连续ID。
- 最终，将window中所有包发送到上层。

## 效率设计

- 使用GBN方式，因为这编写简单但是有效。经过测试，在约发送1000000个bytes时，大约发送60000个包，时长1800s。
- 与参考值相比，时间大大降低，但是还有可提升的地方：
  - 采用SR方式。我只使用了一个全局的timer，这使得设计更方便，不需要不停的更新timer并且使用额外的数据结构来针对每个window中元素储存timer。
  - 包数据可能较小。因为我设置了更长的checksum。但是，如果只使用16位，那么经过测试，在1000次测试中大约有100次出错。这显然是不能容忍的。（使用32位1000次测试出错0次）（测试只需要将rdt_receiver.cc和rdt_sender.cc中header结构体中checksum更改类型即可，后续修改使用decltype和sizeof自动完成）